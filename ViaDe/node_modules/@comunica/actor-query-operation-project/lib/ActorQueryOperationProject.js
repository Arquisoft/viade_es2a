"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const bus_query_operation_1 = require("@comunica/bus-query-operation");
const data_model_1 = require("@rdfjs/data-model");
const rdf_string_1 = require("rdf-string");
/**
 * A comunica Project Query Operation Actor.
 */
class ActorQueryOperationProject extends bus_query_operation_1.ActorQueryOperationTypedMediated {
    constructor(args) {
        super(args, 'project');
    }
    async testOperation(pattern, context) {
        return true;
    }
    async runOperation(pattern, context) {
        // Resolve the input
        const output = bus_query_operation_1.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({ operation: pattern.input, context }));
        // Find all variables that should be deleted from the input stream
        // and all variables that are not bound in the input stream.
        const variables = pattern.variables.map(rdf_string_1.termToString);
        const deleteVariables = output.variables.filter((variable) => variables.indexOf(variable) < 0);
        const missingVariables = variables.filter((variable) => output.variables.indexOf(variable) < 0);
        // Make sure the project variables are the only variables that are present in the bindings.
        let bindingsStream = !deleteVariables.length && !missingVariables.length
            ? output.bindingsStream : output.bindingsStream.map((binding) => {
            for (const deleteVariable of deleteVariables) {
                binding = binding.delete(deleteVariable);
            }
            for (const missingVariable of missingVariables) {
                binding = binding.set(missingVariable, null);
            }
            return binding;
        });
        // Make sure that blank nodes with same labels are not reused over different bindings, as required by SPARQL 1.1.
        // Required for the BNODE() function: https://www.w3.org/TR/sparql11-query/#func-bnode
        let blankNodeCounter = 0;
        bindingsStream = bindingsStream.map((bindings) => {
            blankNodeCounter++;
            return bindings.map((term) => {
                if (term && term.termType === 'BlankNode') {
                    return data_model_1.blankNode(term.value + blankNodeCounter);
                }
                return term;
            });
        });
        return { type: 'bindings', bindingsStream, metadata: output.metadata, variables };
    }
}
exports.ActorQueryOperationProject = ActorQueryOperationProject;
//# sourceMappingURL=ActorQueryOperationProject.js.map