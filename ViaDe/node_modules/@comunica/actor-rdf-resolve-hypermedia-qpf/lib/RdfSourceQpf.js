"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const asynciterator_1 = require("asynciterator");
const asynciterator_promiseproxy_1 = require("asynciterator-promiseproxy");
const rdf_string_1 = require("rdf-string");
const rdf_terms_1 = require("rdf-terms");
/**
 * An RDF source that executes a quad pattern over a QPF interface and fetches its first page.
 */
class RdfSourceQpf {
    constructor(mediatorMetadata, mediatorMetadataExtract, mediatorRdfDereference, subjectUri, predicateUri, objectUri, graphUri, metadata, context, initialQuads) {
        this.mediatorMetadata = mediatorMetadata;
        this.mediatorMetadataExtract = mediatorMetadataExtract;
        this.mediatorRdfDereference = mediatorRdfDereference;
        this.subjectUri = subjectUri;
        this.predicateUri = predicateUri;
        this.objectUri = objectUri;
        this.graphUri = graphUri;
        this.context = context;
        this.cachedQuads = {};
        this.searchForm = this.getSearchForm(metadata);
        if (initialQuads) {
            const wrappedQuads = asynciterator_1.AsyncIterator.wrap(initialQuads);
            wrappedQuads.setProperty('metadata', metadata);
            this.cacheQuads(wrappedQuads);
        }
    }
    /**
     * Get a first QPF search form.
     * @param {{[p: string]: any}} metadata A metadata object.
     * @return {ISearchForm} A search form, or null if none could be found.
     */
    getSearchForm(metadata) {
        if (!metadata.searchForms || !metadata.searchForms.values) {
            return null;
        }
        // Find a quad pattern or triple pattern search form
        const searchForms = metadata.searchForms;
        // TODO: in the future, a query-based search form getter should be used.
        for (const searchForm of searchForms.values) {
            if (this.graphUri
                && this.subjectUri in searchForm.mappings
                && this.predicateUri in searchForm.mappings
                && this.objectUri in searchForm.mappings
                && this.graphUri in searchForm.mappings
                && Object.keys(searchForm.mappings).length === 4) {
                return searchForm;
            }
            if (this.subjectUri in searchForm.mappings
                && this.predicateUri in searchForm.mappings
                && this.objectUri in searchForm.mappings
                && Object.keys(searchForm.mappings).length === 3) {
                return searchForm;
            }
        }
        return null;
    }
    /**
     * Create a QPF fragment IRI for the given quad pattern.
     * @param {ISearchForm} searchForm A search form.
     * @param {Term} subject A term or null.
     * @param {Term} predicate A term or null.
     * @param {Term} object A term or null.
     * @param {Term} graph A term or null.
     * @return {string} A URI.
     */
    createFragmentUri(searchForm, subject, predicate, object, graph) {
        const entries = {};
        const input = [
            { uri: this.subjectUri, term: subject },
            { uri: this.predicateUri, term: predicate },
            { uri: this.objectUri, term: object },
            { uri: this.graphUri, term: graph },
        ];
        for (const entry of input) {
            if (entry.uri && entry.term) {
                entries[entry.uri] = rdf_string_1.termToString(entry.term);
            }
        }
        return searchForm.getUri(entries);
    }
    match(subject, predicate, object, graph) {
        if (subject instanceof RegExp
            || predicate instanceof RegExp
            || object instanceof RegExp
            || graph instanceof RegExp) {
            throw new Error("RdfSourceQpf does not support matching by regular expressions.");
        }
        // Try to emit from cache
        const cached = this.getCachedQuads(subject, predicate, object, graph);
        if (cached) {
            return cached;
        }
        const quads = new asynciterator_promiseproxy_1.PromiseProxyIterator(async () => {
            let url = await this.createFragmentUri(this.searchForm, subject, predicate, object, graph);
            const rdfDereferenceOutput = await this.mediatorRdfDereference.mediate({ context: this.context, url });
            url = rdfDereferenceOutput.url;
            // Determine the metadata and emit it
            const rdfMetadataOuput = await this.mediatorMetadata.mediate({ context: this.context, url, quads: rdfDereferenceOutput.quads, triples: rdfDereferenceOutput.triples });
            this.mediatorMetadataExtract
                .mediate({ context: this.context, url, metadata: rdfMetadataOuput.metadata })
                .then(({ metadata }) => {
                quads.setProperty('metadata', metadata);
                quads.emit('metadata', metadata);
            });
            // The server is free to send any data in its response (such as metadata),
            // including quads that do not match the given matter.
            // Therefore, we have to filter away all non-matching quads here.
            const filteredOutput = asynciterator_1.AsyncIterator.wrap(rdfMetadataOuput.data)
                .filter((quad) => rdf_terms_1.matchPattern(quad, subject, predicate, object, graph));
            return filteredOutput;
        });
        this.cacheQuads(quads, subject, predicate, object, graph);
        return this.getCachedQuads(subject, predicate, object, graph);
    }
    getPatternId(subject, predicate, object, graph) {
        // tslint:disable:object-literal-sort-keys
        return JSON.stringify({
            s: rdf_string_1.termToString(subject),
            p: rdf_string_1.termToString(predicate),
            o: rdf_string_1.termToString(object),
            g: rdf_string_1.termToString(graph),
        });
        // tslint:enable:object-literal-sort-keys
    }
    cacheQuads(quads, subject, predicate, object, graph) {
        const patternId = this.getPatternId(subject, predicate, object, graph);
        this.cachedQuads[patternId] = quads.clone();
    }
    getCachedQuads(subject, predicate, object, graph) {
        const patternId = this.getPatternId(subject, predicate, object, graph);
        let quads = this.cachedQuads[patternId];
        if (quads) {
            const quadsOriginal = quads;
            // Make our iterator lazy to ensure that metadata event is emitted before end event.
            quads = new asynciterator_promiseproxy_1.PromiseProxyIterator(async () => quadsOriginal.clone());
            quadsOriginal.getProperty('metadata', (metadata) => quads.emit('metadata', metadata));
            return quads;
        }
        return null;
    }
}
exports.RdfSourceQpf = RdfSourceQpf;
//# sourceMappingURL=RdfSourceQpf.js.map