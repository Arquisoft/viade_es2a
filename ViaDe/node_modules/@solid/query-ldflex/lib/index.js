"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _ldflex = require("ldflex");

var _context = _interopRequireDefault(require("./context.json"));

var _ContextResolver = _interopRequireDefault(require("./ContextResolver"));

var _SolidDeleteFunctionHandler = _interopRequireDefault(require("./SolidDeleteFunctionHandler"));

var _FindActivityHandler = _interopRequireDefault(require("./FindActivityHandler"));

var _CreateActivityHandler = _interopRequireDefault(require("./CreateActivityHandler"));

var _DeleteActivityHandler = _interopRequireDefault(require("./DeleteActivityHandler"));

var _SourcePathHandler = _interopRequireDefault(require("./SourcePathHandler"));

var _UserPathHandler = _interopRequireDefault(require("./UserPathHandler"));

var _SubjectPathResolver = _interopRequireDefault(require("./SubjectPathResolver"));

var _ComunicaUpdateEngine = _interopRequireDefault(require("./ComunicaUpdateEngine"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const {
  as
} = _context.default['@context'];
const contextResolver = new _ContextResolver.default(_context.default);
let rootPath; // Creates data paths that start from a given subject

const subjectPathFactory = new _ldflex.PathFactory({
  handlers: _objectSpread({}, _ldflex.defaultHandlers, {
    // Custom delete handler to match node-solid-server behavior
    delete: new _SolidDeleteFunctionHandler.default(),
    // Find activities
    findActivity: new _FindActivityHandler.default(),
    likes: (_, path) => path.findActivity("".concat(as, "Like")),
    dislikes: (_, path) => path.findActivity("".concat(as, "Dislike")),
    follows: (_, path) => path.findActivity("".concat(as, "Follow")),
    // Create activities
    createActivity: new _CreateActivityHandler.default(),
    like: (_, path) => () => path.createActivity("".concat(as, "Like")),
    dislike: (_, path) => () => path.createActivity("".concat(as, "Dislike")),
    follow: (_, path) => () => path.createActivity("".concat(as, "Follow")),
    // Delete activities
    deleteActivity: new _DeleteActivityHandler.default(),
    unlike: (_, path) => () => path.deleteActivity("".concat(as, "Like")),
    undislike: (_, path) => () => path.deleteActivity("".concat(as, "Dislike")),
    unfollow: (_, path) => () => path.deleteActivity("".concat(as, "Follow")),
    // The `root` property restarts the path from the root
    root: () => rootPath
  }),
  resolvers: [contextResolver]
}); // Export the root path that resolves the first property access

var _default = rootPath = new _ldflex.PathFactory({
  // Handlers of specific named properties
  handlers: _objectSpread({}, _ldflex.defaultHandlers, {
    // The `from` property takes a source URI as input
    from: new _SourcePathHandler.default(subjectPathFactory),
    // The `user` property starts a path with the current user as subject
    user: new _UserPathHandler.default(subjectPathFactory),
    // Clears the cache for the given document (or everything, if undefined)
    clearCache: (_ref) => {
      let {
        settings
      } = _ref;
      return doc => settings.queryEngine.clearCache(doc);
    },
    // Expose the JSON-LD context
    context: contextResolver
  }),
  // Handlers of all remaining properties
  resolvers: [// `data[url]` starts a path with the property as subject
  new _SubjectPathResolver.default(subjectPathFactory)],
  // Global query engine (currently only used for clearing the cache)
  queryEngine: new _ComunicaUpdateEngine.default()
}).create();

exports.default = _default;