"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _jsonldContextParser = require("jsonld-context-parser");

var _dataModel = require("@rdfjs/data-model");

var _promiseUtils = require("./promiseUtils");

/**
 * Resolves property names of a path
 * to their corresponding IRIs through a JSON-LD context.
 */
class JSONLDResolver {
  /**
   * Creates a new resolver for the given context(s).
   */
  constructor(...contexts) {
    this._context = Promise.resolve({});
    this.extendContext(...contexts);
  }
  /**
   * The JSON-LD resolver supports all string properties.
   */


  supports(property) {
    return typeof property === 'string';
  }
  /**
   * Resolves the property by extending the query path with it.
   */


  resolve(property, pathData) {
    const predicate = (0, _promiseUtils.lazyThenable)(() => this.expandProperty(property));
    const resultsCache = this.getResultsCache(pathData, predicate);
    return pathData.extendPath({
      property,
      predicate,
      resultsCache
    });
  }
  /**
   * Expands a JSON property key into a full IRI.
   */


  async expandProperty(property) {
    // JavaScript requires keys containing colons to be quoted,
    // so prefixed names would need to written as path['foaf:knows'].
    // We thus allow writing path.foaf_knows or path.foaf$knows instead.
    property = property.replace(/^([a-z][a-z0-9]*)[_$]/i, '$1:'); // Expand the property to a full IRI

    const context = await this._context;

    const expandedProperty = _jsonldContextParser.ContextParser.expandTerm(property, context, true);

    if (!_jsonldContextParser.ContextParser.isValidIri(expandedProperty)) throw new Error("The JSON-LD context cannot expand the '".concat(property, "' property"));
    return (0, _dataModel.namedNode)(expandedProperty);
  }
  /**
   * Extends the current JSON-LD context with the given context(s).
   */


  async extendContext(...contexts) {
    await (this._context = this._context.then(currentContext => new _jsonldContextParser.ContextParser().parse([currentContext, ...contexts])));
  }
  /**
   * Gets the results cache for the given predicate.
   */


  getResultsCache(pathData, predicate) {
    let {
      propertyCache
    } = pathData;
    return propertyCache && (0, _promiseUtils.lazyThenable)(async () => {
      propertyCache = await propertyCache;
      return propertyCache && propertyCache[(await predicate).value];
    });
  }

}

exports.default = JSONLDResolver;