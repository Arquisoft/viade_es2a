"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _AsyncIteratorHandler = _interopRequireDefault(require("./AsyncIteratorHandler"));

var _DataHandler = _interopRequireDefault(require("./DataHandler"));

var _DeleteFunctionHandler = _interopRequireDefault(require("./DeleteFunctionHandler"));

var _ExecuteQueryHandler = _interopRequireDefault(require("./ExecuteQueryHandler"));

var _InsertFunctionHandler = _interopRequireDefault(require("./InsertFunctionHandler"));

var _MutationExpressionsHandler = _interopRequireDefault(require("./MutationExpressionsHandler"));

var _PathExpressionHandler = _interopRequireDefault(require("./PathExpressionHandler"));

var _PredicateHandler = _interopRequireDefault(require("./PredicateHandler"));

var _PredicatesHandler = _interopRequireDefault(require("./PredicatesHandler"));

var _PreloadHandler = _interopRequireDefault(require("./PreloadHandler"));

var _PropertiesHandler = _interopRequireDefault(require("./PropertiesHandler"));

var _ReplaceFunctionHandler = _interopRequireDefault(require("./ReplaceFunctionHandler"));

var _SetFunctionHandler = _interopRequireDefault(require("./SetFunctionHandler"));

var _SortHandler = _interopRequireDefault(require("./SortHandler"));

var _SparqlHandler = _interopRequireDefault(require("./SparqlHandler"));

var _StringToLDflexHandler = _interopRequireDefault(require("./StringToLDflexHandler"));

var _SubjectHandler = _interopRequireDefault(require("./SubjectHandler"));

var _SubjectsHandler = _interopRequireDefault(require("./SubjectsHandler"));

var _ThenHandler = _interopRequireDefault(require("./ThenHandler"));

var _ToArrayHandler = _interopRequireDefault(require("./ToArrayHandler"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A map with default property handlers.
 */
var _default = {
  // Flag to loaders that exported paths are not ES6 modules
  __esModule: () => undefined,
  // Add thenable and async iterable behavior
  then: new _ThenHandler.default(),
  [Symbol.asyncIterator]: new _AsyncIteratorHandler.default(),
  // Add read and query functionality
  subject: new _SubjectHandler.default(),
  predicate: new _PredicateHandler.default(),
  properties: new _PropertiesHandler.default(),
  predicates: new _PredicatesHandler.default(),
  pathExpression: new _PathExpressionHandler.default(),
  sparql: new _SparqlHandler.default(),
  subjects: new _SubjectsHandler.default(),
  results: new _ExecuteQueryHandler.default(),
  sort: new _SortHandler.default('ASC'),
  sortDesc: new _SortHandler.default('DESC'),
  preload: new _PreloadHandler.default(),
  // Add write functionality
  mutationExpressions: new _MutationExpressionsHandler.default(),
  add: new _InsertFunctionHandler.default(),
  set: new _SetFunctionHandler.default(),
  replace: new _ReplaceFunctionHandler.default(),
  delete: new _DeleteFunctionHandler.default(),
  // Add RDFJS term handling
  termType: termPropertyHandler('termType'),
  value: termPropertyHandler('value'),
  datatype: termPropertyHandler('datatype'),
  language: termPropertyHandler('language'),
  equals: _DataHandler.default.sync('subject', 'equals'),
  toString: _DataHandler.default.syncFunction('subject', 'value'),
  toPrimitive: _DataHandler.default.syncFunction('subject', 'value'),
  // Add iteration helpers
  toArray: new _ToArrayHandler.default(),
  termTypes: handler((_, path) => path.toArray(t => t.termType)),
  values: handler((_, path) => path.toArray(t => t.value)),
  datatypes: handler((_, path) => path.toArray(t => t.datatype)),
  languages: handler((_, path) => path.toArray(t => t.language)),
  // Parse a string into an LDflex object
  resolve: new _StringToLDflexHandler.default()
}; // Creates a handler from the given function

exports.default = _default;

function handler(handle) {
  return {
    handle
  };
} // Creates a handler for the given RDF/JS Term property


function termPropertyHandler(property) {
  return handler((pathData, path) => {
    // If a resolved subject is present,
    // synchronously expose the RDF/JS property
    const {
      subject
    } = pathData;
    const subjectValue = subject && subject[property];
    if (typeof subjectValue !== 'undefined') return subjectValue; // Otherwise, return a promise to the property value

    return path.then(term => term && term[property]);
  });
}